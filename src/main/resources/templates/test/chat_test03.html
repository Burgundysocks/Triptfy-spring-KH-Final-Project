<!DOCTYPE html>
<html>
<head>
	<meta charset="UTF-8">	
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>CHAT TEST 03</title>
	<style>	
		*{
	    	margin: 0; padding: 0;
	    	box-sizing: border-box;
		}
		
		#chat-wrapper {
			position: fixed;
			bottom: 80px;
			right: 100px;
		}
		#chat-window-btn {
			height: 80px;
			width: 80px;
			
			border-radius: 100%;
			
			box-shadow: 5px 5px 5px lightgray, -2px -2px 5px lightgray, 5px -2px 5px lightgray, -2px 5px 5px lightgray;
			
			/*background-color: lightblue;*/
		}
		#chat-window {
			/* position: absolute;
			bottom: 100px;
			right: 0px; */
			
			height: 600px;
			width: 400px;
			
			border-radius: 20px/20px;
			
			box-shadow: 5px 5px 30px lightgrey, -2px -2px 30px lightgrey, 5px -2px 30px lightgrey, -2px 5px 30px lightgrey;
			
			/*background-color: lightcoral;*/
		}
		#chat-list-empty {
			width: 100%;
			height: 500px;

			display: flex;
			flex-direction: column;
			justify-content: center;
			align-items: center;
			
			/* height: 100%; */
		}
		#cc-logo-empty {
			display: block;
			
			height: 150px;
			width: 150px;
			
			margin-bottom: 20px;
			
			object-fit: cover;
		}
		#chat-list-cont {
			height: 100%;
			width: 100%;
		}
		#chat-list-header{
			width: 100%;
			height: 50px;

			padding: 0 5px 0 5px;

			border-radius: 20px 20px 0 0;

			display: flex;
			flex-direction: row;
			align-content: stretch;
			align-items: center;

			background-color: lightblue;
		}
		#chat-list-footer {
			width: 100%;
			height: 50px;

			background-color: lightblue;

			border-radius: 0 0 20px 20px;

			display: flex;
			font-display: row;
			justify-content: space-between;
		}
		.cc-footer-btn {
			width: 120px;
			height: 50px;
			background-color: lightcoral;
			text-align: center;
			line-height: 50px;
		}
		#chat-list-footer-chatbot-btn {
			border-radius: 0 0 0 20px;
		}
		#chat-list-footer-otm-btn {
			border-radius: 0 0 20px 0;
		}

		#chat-list-chatbot-cont,
		#chat-list-oto-cont,
		#chat-list-otm-cont {
			width: 100%;
			height: 500px;

			display: flex;
			flex-direction: column;

			overflow: scroll;
		}
		#chat-list-oto-cont>div:first-child,
		#chat-list-otm-cont>div:first-child {
			margin-top: 10px;
		}

		#chat-list-oto-cont::-webkit-scrollbar {
			width: 10px;
		}
        #chat-list-oto-cont::-webkit-scrollbar-thumb {
            background-color: lightcoral;
            border-radius: 20px;
            background-clip: padding-box;
            border: 2px solid transparent;
        }
        /* #chat-list-oto-cont::-webkit-scrollbar-track {
            background-color: lightcyan;
        } */

        #chat-body-cont {
            width: 100%;
            height: 100%;
        }
        #chat-body-header {
            width: 100%;
            height: 50px;

            padding: 0 5px 0 5px;

            border-radius: 20px 20px 0 0;

            display: flex;
            flex-direction: row;
            align-content: stretch;
            align-items: center;

            background-color: lightblue;
        }
        #chat-body-inner-cont {
            width: 100%;
            height: 500px;
            
            display: flex;
            /* flex-direction: column-reverse; */
            flex-direction: column;

            overflow: auto;
        }
        /* 참조 https://codingbroker.tistory.com/66 */
        #chat-body-inner-cont::-webkit-scrollbar {
            width: 10px;
        }
        #chat-body-inner-cont::-webkit-scrollbar-thumb {
            background-color: lightcoral;
            border-radius: 20px;
            background-clip: padding-box;
            border: 2px solid transparent;
        }
        /* #chat-body-inner-cont::-webkit-scrollbar-track {
            background-color: lightcyan;
        } */
        #chat-body-input-cont {
            width: 100%;
            height: 50px;

            background-color: lightblue;

            border-radius: 0 0 20px 20px;
        }

        #quit-chat {
            margin-right: 5px;
        }

		.cc-list-oto-ele {
			height: 100px;
			width: 380px;
			margin-left: 8px;
			margin-bottom: 10px;

			border-radius: 15px/15px;

			background-color: lightsalmon;

			/* overflow: hidden; */
			/*
				inline-block 자식 못난놈들 여백 없애기
				https://rgy0409.tistory.com/4678 참조
				자식요소에서 글씨 쓰려면 아래 속성들을 초기화해줘야 함
				특히 fz
			*/
			font-size: 0;
			letter-spacing: 0;
			word-spacing: 0;
		}
		.cc-list-oto-ele>div:first-child {
			display: inline-block;
			height: 100px;
			width: 100px;
			margin-right: 10px;

			font-size: 16px;

			padding-top: 10px;
			padding-left: 10px;
		}
		.cc-list-oto-ele>div:last-child {
			display: inline-block;
			height: 100px;
			width: 270px;

			font-size: 16px;

			vertical-align: top;

			position: relative;

			padding-top: 10px;
		}
		.cc-list-oto-ele>div:first-child>img {
			display: block;
			height: 80px;
			width: 80px;

			border-radius: 10px/10px;

			object-fit: cover;
		}
		/* .cc-list-oto-ele>div:last-child>h4:first-child {
			margin-bottom: 5px;
		} */
		.cc-list-oto-ele>div:last-child>p:nth-child(2) {
			font-size: 12px;
			margin-bottom: 5px;
		}
		.cc-list-oto-ele>div:last-child>p:nth-child(3) {
			font-size: 14px;
			margin-bottom: 8px;
		}
		.cc-list-oto-ele>div:last-child>p:nth-child(4) {
			font-size: 10px;
		}
		.cc-list-oto-ele>div:last-child>div:last-child {
			position: absolute;
			right: 5px;
			bottom: 5px;

			width: 40px;
			height: 40px;

			border-radius: 100%;

			background-color: crimson;

			text-align: center;
			line-height: 40px;
			font-size: 25px;
			color: white;
		}

		.cc-list-otm-ele {
			height: 100px;
			width: 380px;
			margin-left: 8px;
			margin-bottom: 10px;

			border-radius: 15px/15px;

			background-color: lightsalmon;

			/* overflow: hidden; */
			/*
				inline-block 자식 못난놈들 여백 없애기
				https://rgy0409.tistory.com/4678 참조
				자식요소에서 글씨 쓰려면 아래 속성들을 초기화해줘야 함
				특히 fz
			*/
			font-size: 0;
			letter-spacing: 0;
			word-spacing: 0;
		}
		.cc-list-otm-ele>div:first-child {
			display: inline-block;
			height: 100px;
			width: 100px;
			margin-right: 10px;

			/* font-size: 16px; */

			padding-top: 10px;
			padding-left: 10px;
		}
		.cc-list-otm-ele>div:last-child {
			display: inline-block;
			height: 100px;
			width: 270px;

			font-size: 16px;

			vertical-align: top;

			position: relative;

			padding-top: 10px;
		}
		.cc-list-otm-ele>div:first-child>img {
			display: inline-block;
			height: 40px;
			width: 40px;

			/* border-radius: 10px/10px; */

			object-fit: cover;
		}
		.cc-list-otm-ele>div:first-child>img:nth-child(1) {
			border-radius: 10px 0 0 0;
		}
		.cc-list-otm-ele>div:first-child>img:nth-child(2) {
			border-radius: 0 10px 0 0;
		}
		.cc-list-otm-ele>div:first-child>img:nth-child(3) {
			border-radius: 0 0 0 10px;
		}
		.cc-list-otm-ele>div:first-child>img:nth-child(4) {
			border-radius: 0 0 10px 0;
		}

        .ccbody-left, .ccbody-right {
            min-width: 50px;
            max-width: 300px;
            min-height: 20px;
            max-height: fit-content;

			border-radius: 10px/10px;

            font-size: 16px;
            word-break: break-all;

            margin: 0 15px 15px 15px;
            padding: 5px 10px 5px 10px;

            flex-shrink: 0;

            background-color: lightsalmon;
        }
        .ccbody-left {
            margin-right: auto;
        }
        .ccbody-right {
            margin-left: auto;
            margin-right: 5px;
        }
        .ccbody-continue {
            margin-bottom: 5px;
        }
        .ccbody-btn {
            width: 40px;
            height: 40px;
            border: 0;
            /* background-color: transparent; */
        }
		.ccbody-loading {
			position: relative;
		}
		.ccbody-loading::after {
			content: "";
			background: url(/images/chatimg/loading-gif.gif);
			background-size: 18px 18px;
			display: block;
			height: 18px;
			width: 18px;
			position: absolute;
			left: -25px;
			bottom: 1px;
		}

		#chat-alert-cont {
			position: absolute;
			right: 0; top: -80px;
		}
		.cc-alert {
			height: 50px;
			min-width: 100px; max-width: 300px;

			border-radius: 15px/15px;

			padding: 2px 10px 0 10px;

			background-color: rgb(216, 245, 255);
		}
		.cc-alert>h4, .cc-alert>p {
			min-width: 280px;
			overflow: hidden;
			text-overflow: ellipsis;
			white-space: nowrap;
		}
		#chat-inner-wrapper {
			position: absolute;
			bottom: 100px; right: 0px;
		}
		
		.cc-hidden {
			display: none!important;
		}
	</style>
</head>
<body>
	<div id="chat-wrapper">
		<div id="chat-window-btn">채팅<br>이미지 여기에</div>
		<div id="chat-inner-wrapper">
			<div id="chat-alert-cont">
				<!-- <div class="cc-alert">
					<h4>송신자</h4>
					<p>본문aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa</p>
				</div> -->
			</div>
			<div id="chat-window" class="cc-hidden">
				<div id="chat-list-cont" class="">
					<div id="chat-list-header"></div>
					<div id="chat-list-inner-cont">
						<div id="chat-list-empty" class="cc-hidden">
							<!-- 이미지 바꿔라 -->
							<img src="/images/layoutimg/logo.png" id="cc-logo-empty">
							<p>현재 입장해있는 채팅방이 없습니다</p>
						</div>
						<div id="chat-list-chatbot-cont" class="cc-hidden">
							<!-- WIP -->
						</div>
						<div id="chat-list-oto-cont">
							<!-- oto, otm 요소 예시 -->
							<!-- <div id="otoele-1" class="cc-list-oto-ele">
								<div>
									<img src="../../static/images/layoutimg/logo.png" alt="img001">
								</div>
								<div>
									<h4>패키지명 팔라우 바다여행</h4>
									<p>qwerty1234</p>
									<p>네 5박 6일 맞습니다</p>
									<p>5월 28일</p>
									<div>99..</div>
								</div>
							</div>
							<div id="otoele-2" class="cc-list-oto-ele">
								<div>
									<img src="../../static/images/layoutimg/logo.png" alt="img002">
								</div>
								<div>
									<h4>팔라우 6박7일 하루빼고 바다만</h4>
									<p>qwerty1234</p>
									<p>진짜 6일동안 바다만 다녀요?</p>
									<p>5월 28일</p>
									<div class="cc-hidden">0</div>
								</div>
							</div>
							<div id="otoele-2" class="cc-list-otm-ele">
								<div>
									<img src="../../static/images/layoutimg/logo.png" alt="img002">
									<img src="../../static/images/layoutimg/logo.png" alt="img002">
									<img src="../../static/images/layoutimg/logo.png" alt="img002">
									<img src="../../static/images/layoutimg/logo.png" alt="img002">
								</div>
								<div>
									<h4>팔라우 6박7일 하루빼고 바다만</h4>
									<p>qwerty1234</p>
									<p>진짜 6일동안 바다만 다녀요?</p>
									<p>5월 28일</p>
									<div class="cc-hidden">0</div>
								</div>
							</div> -->
						</div>
						<div id="chat-list-otm-cont" class="cc-hidden"></div>
					</div>
					<div id="chat-list-footer">
						<div id="chat-list-footer-chatbot-btn" class="cc-footer-btn">
							<h4>채팅봇</h4>
						</div>
						<div id="chat-list-footer-oto-btn" class="cc-footer-btn">
							<h4>일대일</h4>
						</div>
						<div id="chat-list-footer-otm-btn" class="cc-footer-btn">
							<h4>일대다</h4>
						</div>
					</div>
				</div>
				<div id="chat-body-cont" class="cc-hidden">
					<div id="chat-body-header">
						<input type="submit" value="나가기" id="quit-chat" class="ccbody-btn">
						<h4 id="chat-body-title"></h4>
					</div>
					<div id="chat-body-inner-cont">

					</div>
					<div id="chat-body-input-cont">
						<input type="text" id="input-chat">
						<input type="submit" value="전송" id="submit-chat" class="ccbody-btn">
					</div>
				</div>
			</div>
		</div>
	</div>
</body>
<script>
	/*================================================================================*/
	/*HTML 요소 전역변수*/
	//채팅창 버튼
	const CHAT_WINDOW_BTN = document.getElementById("chat-window-btn");
	//채팅창
	const CHAT_WINDOW = document.getElementById("chat-window");

	//채팅 알림창
	const CHAT_ALERT_CONT = document.getElementById("chat-alert-cont");
	
	//채팅방 목록창 container
	const CHAT_LIST_CONT = document.getElementById("chat-list-cont");
	//빈 채팅방 목록
	const CHAT_LIST_EMPTY = document.getElementById("chat-list-empty");
	//챗봇창
	const CHAT_LIST_CHATBOT = document.getElementById("chat-list-chatbot-cont");
	//일대일 목록창
	const CHAT_LIST_OTO = document.getElementById("chat-list-oto-cont");
	//다대다 목록창
	const CHAT_LIST_OTM = document.getElementById("chat-list-otm-cont");
	//채팅리스트창 푸터
	const CHAT_LIST_FOOTER = document.getElementById("chat-list-footer");
	//채팅방 목록창 푸터 버튼 <--이새끼들 필요없을거같은데
	const CHAT_LIST_CHATBOT_BTN = document.getElementById("chat-list-footer-chatbot-btn");
	const CHAT_LIST_OTO_BTN = document.getElementById("chat-list-footer-oto-btn");
	const CHAT_LIST_OTM_BTN = document.getElementById("chat-list-footer-otm-btn");

	//채팅창 container
	const CHAT_BODY_CONT = document.getElementById("chat-body-cont");
	//채팅창 본문구역
	const CHAT_BODY_INNER_CONT = document.getElementById("chat-body-inner-cont");
	//title
	const CHAT_BODY_TITLE = document.getElementById("chat-body-title");
	//채팅창 나가기 버튼
	const CHAT_BODY_QUIT_BTN = document.getElementById("quit-chat");
	//채팅 전송 버튼
	const CHAT_BODY_SUBMIT_BTN = document.getElementById("submit-chat");
	//채팅 입력창
	const CHAT_BODY_INPUT = document.getElementById("input-chat");

	/*================================================================================*/
	/*공유 워커 관련*/

	let WORKER = null;

	window.addEventListener("load", function(e) {
		if(!!window.SharedWorker) {
			//공유워커 지원 브라우저
			WORKER = new SharedWorker("http://localhost:8080/js/chat/chatworkertemp.js", "tripfy-chatworker");

			WORKER.port.onmessage = (e) => {
				//공유워커에서 메세지 수신시
				//일단 콘솔로그만 해둠
				console.log("SharedWorder broadcasted data=" + e.data);
				console.log(e.data);
				switch(e.data.action) {
					case "broadcastChat":
						broadcastChatHandler(e.data);
						break;
				}
			};

			window.addEventListener("beforeunload", (e) => {
				WORKER.port.postMessage({
					action: "closePort"
				});
			});

			WORKER.port.start();
		} else {
			//공유워커 미지원 브라우저
			window.close();
		}
	});
	/*
		!!!! 테스트
	*/
	// CHAT_BODY_INNER_CONT.addEventListener("scroll", (e) => {
	// 	console.log(CHAT_BODY_INNER_CONT.scrollY);
	// });

	/*================================================================================*/
	/*클릭이벤트 등록*/
	
	//채팅창 버튼
	CHAT_WINDOW_BTN.addEventListener("click", chatWindowBtnClick);
	//채팅리스트창 푸터 버튼 클릭 감지
	CHAT_LIST_FOOTER.addEventListener("click", chatListFooterBtnClick);
	//채팅리스트 요소 클릭 감지
	CHAT_LIST_OTO.addEventListener("click", chatListOTNElementClick);
	CHAT_LIST_OTM.addEventListener("click", chatListOTNElementClick);
	//채팅창 나가기 버튼 클릭
	CHAT_BODY_QUIT_BTN.addEventListener("click", chatBodyQuitBtnClick);
	//채팅 submit 버튼 클릭
	CHAT_BODY_SUBMIT_BTN.addEventListener("click", chatBodySubmitBtnClick);

	/*================================================================================*/
	/*채팅 생성*/
	function createPackageChat(e) {
		const packagenum = 0; /*초기화 필요*/

		ajaxPost("localhost:8080", "/chat", {
			isPackageChat: true,
			packagenum: packagenum
		})
		.then((data) => {
			//ChatListPayloadDTO 받아옴
		})
		.catch((err) => {

		});
	}

	/*================================================================================*/
	/*이벤트 관련 함수*/

	//채팅창 버튼 클릭
	/*
		채팅창 열기 <-> 닫기
		이미 로드된 채팅창이 있을 경우 서버 요청을 하지 않음

		이거 나중에 기존 로드내역과 무관하게
		채탕창 열 때마다 다시 Ajax로 로드하게 바꿔주자
		그래야 편하게 새로고침할거아님
		+ 그런 경우 로드시마다 기존 채팅방리스트는 날리고 새로 넣어줘야 함
	*/
	function chatWindowBtnClick(e) {
		if(CHAT_WINDOW.classList.contains("cc-hidden")) {
			CHAT_WINDOW.classList.remove("cc-hidden");
			// if(CHAT_OTO_VD.length == 0 && CHAT_OTM_VD.length == 0) { <--매번 로드하게끔 임시로 가려둠
				//Ajax 호출
				ajaxGet("localhost:8080", "/chat")
				.then((data) => {
					console.log(data);
					setChatListVD(data);
					printChatList();
				})
				.catch((error) => {
					/*
						에러 발생시 채팅창 전개를 막고
						오류 팝업을 띄워야 함
					*/
					console.log("err");
					console.log(error);
				});
			// }
		} else {
			CHAT_WINDOW.classList.add("cc-hidden");
		}
	}

	//채팅방 리스트창 푸터 버튼들 클릭
	/*
		이벤트 버블링 사용
	*/
	function chatListFooterBtnClick(e) {
		if(e.target.parentElement.classList.contains("cc-footer-btn") || e.target.classList.contains("cc-footer-btn")) {
			const clickedId = e.target.parentElement.classList.contains("cc-footer-btn")
							? e.target.parentElement.id
							: e.target.id;
			switch(clickedId) {
				case "chat-list-footer-chatbot-btn":
					//채팅봇
					//임마는 일단 안 적어둠
					break;
				case "chat-list-footer-oto-btn":
					//일대일
					if(CHAT_OTO_VD.length > 0) {
						CHAT_LIST_EMPTY.classList.add("cc-hidden");
						CHAT_LIST_CHATBOT.classList.add("cc-hidden");
						CHAT_LIST_OTM.classList.add("cc-hidden");

						CHAT_LIST_OTO.classList.remove("cc-hidden");
					} else {
						CHAT_LIST_CHATBOT.classList.add("cc-hidden");
						CHAT_LIST_OTO.classList.add("cc-hidden");
						CHAT_LIST_OTM.classList.add("cc-hidden");

						CHAT_LIST_EMPTY.classList.remove("cc-hidden");
					}
					break;
				case "chat-list-footer-otm-btn":
					//다대다
					if(CHAT_OTM_VD.length > 0) {
						CHAT_LIST_EMPTY.classList.add("cc-hidden");
						CHAT_LIST_CHATBOT.classList.add("cc-hidden");
						CHAT_LIST_OTO.classList.add("cc-hidden");
						
						CHAT_LIST_OTM.classList.remove("cc-hidden");
					} else {
						CHAT_LIST_CHATBOT.classList.add("cc-hidden");
						CHAT_LIST_OTO.classList.add("cc-hidden");
						CHAT_LIST_OTM.classList.add("cc-hidden");

						CHAT_LIST_EMPTY.classList.remove("cc-hidden");
					}
					break;
			}
		}
	}

	//채팅리스트창 요소 클릭
	/*
		이벤트 버블링 사용
	*/
	async function chatListOTNElementClick(e) {
		//oto/otm중 어디가 클릭되었는지 파악
		let targetID;
		if(e.currentTarget.id === "chat-list-oto-cont") {
			targetID = "otoele";
		} else {
			targetID = "otmele";
		}

		//클릭된 요소 id 찾기
		let targetEleId = null;

		if(e.target.parentElement.parentElement.id.split("-")[0] === targetID) {
			targetEleId = e.target.parentElement.parentElement.id;
		} else if(e.target.parentElement.id.split("-")[0] === targetID) {
			targetEleId = e.target.parentElement.id;
		} else if(e.target.id.split("-")[0] === targetID) {
			targetEleId = e.target.id;
		}

		//요소의 정보 가져오기
		let targetInfo = null;

		if(!!targetEleId) {
			for(let objEle of (targetID === "otoele" ? CHAT_OTO_VD : CHAT_OTM_VD)) {
				if(objEle.eleId === targetEleId) {
					targetInfo = objEle.dataObj;
					break;
				}
			}
			//일단 targetEleId와 일치하는 CHAT_OT*_VD[n].eleId 가 없는 경우는 체크하지 않음
			//웹소켓 연결 요청
			WORKER.port.postMessage({
				action: "chatRoomEnter",
				payload: {
					roomidx: targetInfo.roomidx
				}
			});
			//응답 대기/처리
			try {
				const res = await promised_waitTillResponse("chatRoomEnter");
				//모달 구성
				setChatBodyInfo(res.payload);
				printChatRoom(res.payload);
				//UNCHECKED_MSG_COUNT 값과
				//CHAT_OT*_VD uncheckedmsg 값 갱신
				//대충 UNCHECKED_MSG_COUNT -= uncheckedmsg를 해준다
				UNCHECKED_MSG_COUNT -= targetInfo.uncheckedmsg;
				for(let key in (targetID === "otoele" ? CHAT_OTO_VD : CHAT_OTM_VD)) {
					if((targetID === "otoele" ? CHAT_OTO_VD : CHAT_OTM_VD)[key].eleId === targetEleId) {
						(targetID === "otoele" ? CHAT_OTO_VD : CHAT_OTM_VD)[key].dataObj.uncheckedmsg = 0;
						break;
					}
				}
				if(CHAT_BODY_INFO.isEmpty == false) {
					scrollIntoLastChatElement();
				}
				/*미확인 채팅값 갱신 DOM에 적용*/

			} catch(err) {
				//채팅방 로딩 실패 출력
				/*
					각 페이즈? 별 페이지들을 열어주는 함수들이 있으면 좋을듯?
					막 지금 chatListFooterBtnClick()이 하는걸
					거 안에 classList 만지는 부분을 각각 독립시키면 좀 편할거같음
				*/
				//임시
				window.alert("채팅방 로딩을 실패했습니다");
				console.log(err);
			}
		}
	}

	//채팅창 나가기 버튼 클릭
	/*
		웹소켓 연결을 끊는 것은 여기서 관여하지 않음
	*/
	async function chatBodyQuitBtnClick(e) {
		//SharedWorker에게 요청
		WORKER.port.postMessage({
			action: "chatRoomLeave",
			payload: {
				roomidx: CHAT_BODY_INFO.roomidx
			}
		});

		//응답 대기/처리
		try {
			const res = await promised_waitTillResponse("chatRoomLeave");
			//모달 구성
			resetChatBodyInfo();
			//임시
			CHAT_BODY_CONT.classList.add("cc-hidden");
			CHAT_LIST_CONT.classList.remove("cc-hidden");
		} catch(err) {
			//채팅방 이탈 실패 출력
			//임시
			window.alert("채팅방 나가기를 실패했습니다");
			console.log(err);
		}
	}

	//채팅창 입력 submit 클릭
	/*
		입력 로직
		submit
		-> 우선 DOM에 채팅(로딩) 올리기
		-> 서버 찍턴
		-> 성공시 채팅(로딩)을 채팅으로 변경
			-> 실패시 채팅(로딩)을 채팅(실패)으로 변경
			-> UI로 버튼 2개 제공, resubmit, cancelsubmit 정도
				-> cancelsubmit 시 DOM서 삭제
				-> resubmit 시 서버찍턴 goto

		일단은 서버 찍턴 -> 성공/실패에 따라 처리 정도로만 함
	*/
	async function chatBodySubmitBtnClick(e) {
		const inputContent = CHAT_BODY_INPUT.value;

		if(inputContent != "") {
			printChatElement("loading", inputContent, "ccbody-right", "ccbody-loading");
			scrollIntoLastChatElement();

			WORKER.port.postMessage({
				action: "sendChat",
				payload: {
					roomidx: CHAT_BODY_INFO.roomidx,
					chatContent: inputContent
				}
			});
	
			//응답 대기/처리
			try {
				const res = await promised_waitTillResponse("sendChat");
				/*VD 조작 함수 호출*/
				/*DOM 구현 함수 호출*/
				adjustChatElementClass("ccbodyele-loading", "ccbody-right");
				adjustChatElementId("ccbodyele-loading", "ccbody-" + res.chatDetailIdx);
			} catch(e) {
				//오류 처리
			}
		} else {
			//공란 입력 불가능 알림
		}
	}

	//broadcastChat 수신기
	/*
		채팅방이 닫혀있으면 팝업알림만,
		열려있으면 채팅방 갱신도

		두 경우 모두 채팅창이 열린 적이 있으면(CHAT_OT*_VD가 비어있지 않으면)
		UNCHECKED_MSG_COUNT--과 CHAT_OT*_VD.uncheckedmsg--를 해준다

		이거 좀 생각보다 복잡함
	*/
	function broadcastChatHandler(data) {
		if(!!CHAT_BODY_INFO.roomidx) {
			//채팅창이 열려있을 때
			printChatElement(data.payload.chatDetailIdx, data.payload.chatContent, "ccbody-left");
			scrollIntoLastChatElement();
		} else {
			//채팅창이 닫혀있을 때
			UNCHECKED_MSG_COUNT++;
			let chk = true;

			for(let i = 0; i < CHAT_OTO_VD.length; i++) {
				if(CHAT_OTO_VD[i].dataObj.roomidx === data.payload.roomidx) {
					CHAT_OTO_VD[i].dataObj.uncheckedmsg++;
					chk = false;
					break;
				}
			}
			if(chk) {
				for(let i = 0; i < CHAT_OTM_VD.length; i++) {
					if(CHAT_OTM_VD[i].dataObj.roomidx === data.payload.roomidx) {
						CHAT_OTM_VD[i].dataObj.uncheckedmsg++;
						break;
					}
				}
			}

			/*미확인 체팅 알림처리*/
			console.log("미확인 채팅 알림처리");

			const div = document.createElement("div");
			div.classList.add("cc-alert");
			const h4 = document.createElement("h4");
			h4.innerHTML = data.payload.userid;
			div.appendChild(h4);
			const p = document.createElement("p");
			p.innerHTML = data.payload.chatContent;
			div.appendChild(p);
			CHAT_ALERT_CONT.appendChild(div);
			console.log(div);
			setTimeout(() => {
				div.remove();
				console.log("div removed");
			}, 3000);
		}
	}

	/*================================================================================*/
	/*연결*/
	//비동기 응답 대기
	async function promised_waitTillResponse(action, millisec = 3000) {
		return new Promise((resolve, reject) => {
			const receiver = (e) => {
				if(e.data.action === action) {
					if(e.data.isSuccess === true) {
						resolve(e.data);
					} else {
						reject(new Error("reportFromWorker"));
					}
					WORKER.port.removeEventListener("message", receiver);
					clearTimeout(timeoutId);
				}
			};

			const timeoutId = setTimeout(() => {
				console.log("promised_waitTillResponse timeout call");
				if(!!WORKER)
					WORKER.removeEventListener("message", receiver);
				reject(new Error("timeout"));
			}, millisec);
			WORKER.port.addEventListener("message", receiver);
		});
	}

	/*================================================================================*/
	/*VD 처리/데이터 처리*/

	//채팅방 VD 정리
	/*
		정렬 기준은 regdate
		최초 로드인 경우 key값 i를 0으로, 그 외의 경우 CHAT_ROOM_CNT를 기준으로 함

		240603
		이제 한번에 모든 채팅을 불러오는 구조로 바뀜
		+ 일대일 일대다 출력 별개로

		따라서 VD를 나눌 필요가 있겠음

		+ VD 목적
		거창한 가상돔 그런거보다는
		채팅방 정보를 HTML에 저장하는 구조가 좀 그런게 크다
		채팅방 정보를 저장하는 목적

		VD 구성
		은 배열로 한다
		생각해보니까 key-value면 정렬할때 좆됨

		!!!!!!!중요
		채팅방 ID는 정렬 순서가 아니라 roomidx로 준다
	*/

	//일대일 VD
	let CHAT_OTO_VD = [];
	//일대다 VD
	let CHAT_OTM_VD = [];
	//채팅방 저장객체 생성자
	function ChatRoom(eleId, dataObj) {
		this.eleId = eleId;
		this.dataObj = dataObj;
	}
	//총 안 읽은 개수
	let UNCHECKED_MSG_COUNT = 0;
	
	let CHAT_FIRST_DETAIL_IDX = null;

	const CHAT_BODY_INFO = {
		roomidx: null,
		isEmpty: false,
		firstDetailIdx: null,
		isFirst: null,
		userid: null,
		chatRoomInfo: null
	};

	//VD 처리
	//VD 초기화
	/*
		!!중요 - "초기화"임 기존 요소들이랑 미확인카운팅값 날린다
	*/
	function setChatListVD(data) {
		//기존값 초기화
		CHAT_OTO_VD = [];
		CHAT_OTM_VD = [];
		UNCHECKED_MSG_COUNT = 0;

		//data의 userList.length가 1인지 1 이상인지 체크, oto과 otm을 나눈다
		for(let clObj of data) {
			if(clObj.userList.length == 1) {
				//oto
				CHAT_OTO_VD.push(new ChatRoom("otoele-" + clObj.roomidx, clObj));
			} else {
				//otm
				CHAT_OTM_VD.push(new ChatRoom("otmele-" + clObj.roomidx, clObj));
			}
		}
	}
	//VD 업데이트
	function updateChatListVD(data) {
		//data가 존재하는지 확인, 존재하면 순서를 바꾸고 없으면 제일 최상위에 삽입
	}

	//CHAT_BODY_INFO 세팅
	/*
	*/
	function setChatBodyInfo(payload) {
		if(!payload.startChatDetailIdx && !payload.endChatDetailIdx) {
			CHAT_BODY_INFO.isEmpty = true;
			CHAT_BODY_INFO.firstDetailIdx = null;
			CHAT_BODY_INFO.isFirst = null;
		} else {
			CHAT_BODY_INFO.isEmpty = false;
			CHAT_BODY_INFO.firstDetailIdx = payload.startChatDetailIdx;
			CHAT_BODY_INFO.isFirst = payload.isFirst;
		}
		CHAT_BODY_INFO.roomidx = payload.roomidx;
		CHAT_BODY_INFO.userid = payload.requestUserid;

		let chk = true;

		for(let temp of CHAT_OTO_VD) {
			if(temp.dataObj.roomidx === payload.roomidx) {
				CHAT_BODY_INFO.chatRoomInfo = temp.dataObj;
				chk = false;
				break;
			}
		}
		if(chk) {
			for(let temp of CHAT_OTM_VD) {
				if(temp.dataObj.roomidx === payload.roomidx) {
					CHAT_BODY_INFO.chatRoomInfo = temp.dataObj;
					break;
				}
			}
		}
	}
	//CHAT_BODY_INFO 초기화
	function resetChatBodyInfo() {
		CHAT_BODY_INFO.roomidx = null;
		CHAT_BODY_INFO.isEmpty = false;
		CHAT_BODY_INFO.firstDetailIdx = null;
		CHAT_BODY_INFO.isFirst = null;
		CHAT_BODY_INFO.userid = null;
		CHAT_BODY_INFO.chatRoomInfo = null;
	}

	/*================================================================================*/
	/*DOM 구현*/

	//채팅창 요소 구현
	//메시지(로딩)
	function printChatElement(idValue, chatContent, ...classList) {
		const div = document.createElement("div");
		div.id = "ccbodyele-" + idValue;
		if(classList.length > 0) {
			classList.forEach((cls) => {
				div.classList.add(cls);
			});
		}
		const p = document.createElement("p");
		p.innerHTML = chatContent;
		div.appendChild(p);
		CHAT_BODY_INNER_CONT.appendChild(div);
	}
	//특정 메시지 클래스 수정
	/*
		매개변수 classList[]의 값으로 덮어씌움
	*/
	function adjustChatElementClass(idValue, ...classList) {
		const target = document.getElementById(idValue);
		target.removeAttribute("class");
		if(classList.length > 0)
			classList.forEach((cls) => {
				target.classList.add(cls);
			});
	}
	//특정 메시지 id 수정
	/*
		수정된 id를 반환
	*/
	function adjustChatElementId(oldIdValue, newIdValue) {
		document.getElementById(oldIdValue).id = newIdValue;
		return newIdValue;
	}

	//마지막 요소 포커스
	function scrollIntoLastChatElement() {
		CHAT_BODY_INNER_CONT.lastChild.scrollIntoView(false);
	}

	//채팅창 DOM 구현
	/*
		처음 채팅창 로드시 한번만 실행

		일단 지금은 메시지 좌우 구분, id/class 부여와 내부 본문 출력까지만 함
	*/
	function printChatRoom(payload) {
		//기존 채팅 초기화
		CHAT_BODY_INNER_CONT.replaceChildren();
		if(CHAT_BODY_INFO.isEmpty) {
			CHAT_FIRST_DETAIL_IDX = null;
		} else {
			CHAT_FIRST_DETAIL_IDX = payload.chatDetails[payload.chatDetails.length - 1].chatDetailIdx;
		}

		//채팅창 화면 변경
		CHAT_LIST_CONT.classList.add("cc-hidden");
		CHAT_BODY_CONT.classList.remove("cc-hidden");

		//채팅창 제목
		if(!!CHAT_BODY_INFO.chatRoomInfo.pkgnum) {
			//패키지채팅
			CHAT_BODY_TITLE.innerHTML = CHAT_BODY_INFO.chatRoomInfo.title;
		} else {
			//일반채팅
			if(!!CHAT_BODY_INFO.chatRoomInfo.title) {
				//방제 있음
				CHAT_BODY_TITLE.innerHTML = CHAT_BODY_INFO.chatRoomInfo.title;
			} else {
				//방제 없음
				//userid들 묶은 문자열 생성
				let userids = "";
				for(let dto of CHAT_BODY_INFO.chatRoomInfo.userList) {
					userids += dto.userid + ",";
				}
				userids = userids.slice(0, -1);

				CHAT_BODY_TITLE.innerHTML = userids;
			}
		}

		//채팅 내역이 없으면 여기서 종료
		if(CHAT_BODY_INFO.isEmpty) {
			return;
		}

		//fragment
		const chatFragment = document.createDocumentFragment();

		//채팅 요소 생성
		for(let cd of payload.chatDetails) {
			const div = document.createElement("div");
			div.id = "ccbodyele-" + cd.chatDetailIdx;
			if(cd.userid === payload.requestUserid) {
				div.classList.add("ccbody-right");
			} else {
				div.classList.add("ccbody-left");
			}
			const p = document.createElement("p");
			p.innerHTML = cd.chatDetailContent;
			div.appendChild(p);
			chatFragment.prepend(div);
		}

		CHAT_BODY_INNER_CONT.appendChild(chatFragment);
	}

	//채팅방 DOM 구현
	//단순히 채팅창 목록에 요소를 채워넣기만 하는 메서드임 추가적인(cc-hidden 등)조작은 안함
	//	다만 counterDiv(미확인 채팅 개수 출력)만은 cc-hidden 할당 체크함
	//일단 임마는 채팅방 리스트가 닫혀 있어도(정확히는 채팅창이 열려 있어도) 작동하지는.. 않음
	//해당 페이지서 최초 채팅창 로드시 한번만 실행되는거임
	/*
		이거 생각해보니까 채팅창 열 때가 아니라
		페이지 로드시 바로 해줘야할거같음
		그래야 UNCHECKED_MSG_COUNT 초기화가 제때 됨
	*/
	function printChatList() {
		//우선 기존 DOM 초기화
		CHAT_LIST_OTO.replaceChildren();
		CHAT_LIST_OTM.replaceChildren();

		//oto
		const otoFragment = document.createDocumentFragment();
		//otm
		const otmFragment = document.createDocumentFragment();
		
		//oto 요소 생성
		for(let arrEle of CHAT_OTO_VD) {
			//안 읽은 챗 개수 합산
			UNCHECKED_MSG_COUNT += arrEle.uncheckedmsg;

			//요소 틀
			const div = document.createElement("div");
			div.id = arrEle.eleId;
			div.classList.add("cc-list-oto-ele");
			//첫 자식 div
			const innerDivFir = document.createElement("div");
			div.appendChild(innerDivFir);
			//이미지
			/*
				추후 서버에서 이미지 링크를 받아 실제로 출력하게끔 수정해야함
			*/
			const img = document.createElement("img");
			img.src = "/images/layoutimg/logo.png";
			img.alt = "Chat room image";
			innerDivFir.appendChild(img);
			//두번째 자식 div
			const innerDivSec = document.createElement("div");
			div.appendChild(innerDivSec);

			//title, p1(userid) 생성
			const h4 = document.createElement("h4");
			const p1 = document.createElement("p");

			//title, userid 처리 관련 분기(일반/일반 <-> 판매자/일반)
			if(!!arrEle.pkgnum) {
				//판매자/일반
				h4.innerHTML = arrEle.dataObj.title;
				p1.innerHTML = arrEle.dataObj.userList[0].userid;
			} else {
				//일반/일반
				if(!!arrEle.title) {
					h4.innerHTML = arrEle.dataObj.title;
					p1.innerHTML = arrEle.dataObj.userList[0].userid;
				} else {
					h4.innerHTML = arrEle.dataObj.userList[0].userid;
				}
			}
			
			//title, userid 할당
			innerDivSec.appendChild(h4);
			innerDivSec.appendChild(p1);
		
			//p2(chatContent)
			const p2 = document.createElement("p");
			p2.innerHTML = !!arrEle.dataObj.chatContent
							? arrEle.dataObj.chatContent
							: "아직 메시지가 없습니다";
			innerDivSec.appendChild(p2);
			//p3(chatContentRegdate 혹은 chatRegdate)
			const p3 = document.createElement("p");
			p3.innerHTML = !!arrEle.dataObj.chatContent
							? arrEle.dataObj.chatContentRegdate
							: arrEle.dataObj.chatRegdate;
			innerDivSec.appendChild(p3);
			//div(미확인 메시지 카운터)
			const counterDiv = document.createElement("div");
			if(arrEle.dataObj.uncheckedmsg > 0) {
				counterDiv.innerHTML = arrEle.dataObj.uncheckedmsg > 99 ? "99.." : arrEle.dataObj.uncheckedmsg;
			} else {
				counterDiv.classList.add("cc-hidden");
			}
			innerDivSec.appendChild(counterDiv);

			//fragment에 삽입
			otoFragment.appendChild(div);
		}

		//otm 요소 생성
		for(let arrEle of CHAT_OTM_VD) {
			//안 읽은 챗 개수 합산
			UNCHECKED_MSG_COUNT += arrEle.uncheckedmsg;

			//요소 틀
			const div = document.createElement("div");
			div.id = arrEle.eleId;
			div.classList.add("cc-list-otm-ele");
			//첫 자식 div
			const innerDivFir = document.createElement("div");
			div.appendChild(innerDivFir);
			//이미지
			/*
				추후 서버에서 이미지 링크를 받아 실제로 출력하게끔 수정해야함
				+ 이미지도 List<>로 가져오게 해야 함
				반복문도 최대 4번이지만 이미지 개수 < 4 인 경우 그 만큼만 돌게 하고
				참여자가 3명일 때(유저 포함) 이미지를 기존 4등분이 아닌 좌우 2등분으로 바꿀 수 있게
				css도 짜 줘야 함
			*/
			for(let i = 0 ; i < 4; i++) {
				const img = document.createElement("img");
				img.src = "/images/layoutimg/logo.png";
				img.alt = "Chat room image";
				innerDivFir.appendChild(img);
			}
			//두번째 자식 div
			const innerDivSec = document.createElement("div");
			div.appendChild(innerDivSec);

			//title, p1(userid) 생성
			const h4 = document.createElement("h4");
			const p1 = document.createElement("p");

			//userid들 묶은 문자열 생성
			let userids = "";
			for(let dto of arrEle.dataObj.userList) {
				userids += dto.userid + ",";
			}
			userids = userids.slice(0, -1);

			//title, userid 처리 관련 분기(일반/일반 <-> 판매자/일반)
			if(!!arrEle.pkgnum) {
				//판매자/일반
				h4.innerHTML = arrEle.dataObj.title;
				p1.innerHTML = userids;
			} else {
				//일반/일반
				if(!!arrEle.title) {
					h4.innerHTML = arrEle.dataObj.title;
					p1.innerHTML = userids;
				} else {
					h4.innerHTML = userids;
				}
			}
			
			//title, userid 할당
			innerDivSec.appendChild(h4);
			innerDivSec.appendChild(p1);
		
			//p2(chatContent)
			const p2 = document.createElement("p");
			p2.innerHTML = !!arrEle.dataObj.chatContent
							? arrEle.dataObj.chatContent
							: "아직 메시지가 없습니다";
			innerDivSec.appendChild(p2);
			//p3(chatContentRegdate 혹은 chatRegdate)
			const p3 = document.createElement("p");
			p3.innerHTML = !!arrEle.dataObj.chatContent
							? arrEle.dataObj.chatContentRegdate
							: arrEle.dataObj.chatRegdate;
			innerDivSec.appendChild(p3);
			//div(미확인 메시지 카운터)
			const counterDiv = document.createElement("div");
			if(arrEle.dataObj.uncheckedmsg > 0) {
				counterDiv.innerHTML = data.dataObj.uncheckedmsg > 99 ? "99.." : data.dataObj.uncheckedmsg;
			} else {
				counterDiv.classList.add("cc-hidden");
			}
			innerDivSec.appendChild(counterDiv);

			//fragment에 삽입
			otmFragment.appendChild(div);
		}

		//DOM에 fragment들 삽입
		CHAT_LIST_OTO.appendChild(otoFragment);
		CHAT_LIST_OTM.appendChild(otmFragment);
	}

	//채팅방 요소 내부 수정 - 미수정 240604
	function adjustChatList(targetEle, dataObj) {
		const secInnerDiv = targetEle.children[1];

		//title
		if(secInnerDiv.children[0].innerHTML != dataObj.pkgname) {
			secInnerDit.children[0].innerHTML = dataObj.pkgname;
		}
		//userid - 마지막 송신자
		if(secInnerDiv.children[1].innerHTML != dataObj.userid) {
			secInnerDiv.children[1].innerHTML = dataObj.userid;
		}
		// - 마지막 메시지 내용
		if(secInnerDiv.children[2].innerHTML != dataObj.chatContent) {
			secInnerDiv.children[2].innerHTML = dataObj.chatContent;
		}
		//regdate
		if(secInnerDiv.children[3].innerHTML != dataObj.regdate) {
			secInnerDiv.children[3].innerHTML != dataObj.regdate;
		}
		//미수신 개수
		//는 일단 미정
		if(secInnerDiv.children[4].innerHTML != dataObj.uncheckedmsg) {
			secInnerDiv.children[4].innerHTML = dataObj.uncheckedmsg;
		}
		if(dataObj.uncheckedmsg == 0) {
			secInnerDiv.children[4].classList.add("cc-hidden");
		} else {
			secInnerDiv.children[4].classList.remove("cc-hidden");
		}
	}

	/*================================================================================*/
	/*AJAX*/
	/*
		대충 get 사용법
		ajaxGet("localhost:8080", "/chat", {
			//쿼리스트링에 넣을 키-값을 js 객체 형태로 삽입
			// 넣을 쿼리스트링이 없으면 생략 가능함
			"userid1": USER_ID,
			"userid2": "qwerty1234",
			"userid3": document.getElementById("simpleexampleelementid").value,
			...
		})
		.then((data) => {
			//대충 받은 데이터 사용하는 로직
		})
		.catch((error) => {
			//에러 발생시 로직
		});

		post 사용법
		ajaxPost("localhost:8080", "/chat", {
			//body에 넣을 키-값 value
			// js 객체 형태로 삽입
		}, {
			//header에 넣을 키-값 value
			// js 객체 형태로 삽입
			// 없으면 생략
		})
		.then((data) => {
			//받은 데이터 사용하는 로직
		})
		.catch((error) => {
			//에러 처리 로직
		});

		queryStrings, body, header는 js 객체 형태로 삽입
		반환되는 데이터는 무조건 JSON으로 수신 -> JS 객체화
	*/
	//GET
	async function ajaxGet(host, path, queryStrings={}) {
		let qs = "";
		if(Object.keys(queryStrings).length > 0) {
			qs += "?";
			for(let key in queryStrings) {
				qs += key + "=" + queryStrings[key] + "&";
			}
			qs = qs.replace(/\&$/, "");
		}

		const url = "http://" + host + path + qs;

		const res = await fetch(url);
		const data = await res.json();

		if(res.ok) {
			return data;
		} else {
			throw Error(res);
		}
	}
	//POST
	async function ajaxPost(host, path, body, header={}) {
		const url = "http://" + host + path;
		const options = {
			method: "POST",
			headers: {
				"Content-Type": "application/json",
				...headers,
			},
			body: JSON.stringify(body)
		};

		const res = await fetch(url, options);
		const data = await res.json();

		if(res.ok) {
			return data;
		} else {
			throw Error(res);
		}
	}
</script>
</html>